/*
    automatically generated by rust-bindgen with:
    bindgen.exe --whitelist-function=GetAdaptersAddresses wrapper.h -- --target=x86_64-pc-windows-msvc
*/

pub type wchar_t = ::std::os::raw::c_ushort;
pub type ULONG = ::std::os::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = ::std::os::raw::c_ushort;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BYTE = ::std::os::raw::c_uchar;
pub type INT = ::std::os::raw::c_int;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT32 = ::std::os::raw::c_uint;
pub type ULONG64 = ::std::os::raw::c_ulonglong;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type PCHAR = *mut CHAR;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    assert_eq!(
        ::std::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _GUID)).Data1 as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _GUID)).Data2 as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _GUID)).Data3 as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _GUID)).Data4 as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data4)
        )
    );
}
impl Clone for _GUID {
    fn clone(&self) -> Self {
        *self
    }
}
pub type GUID = _GUID;
pub type ADDRESS_FAMILY = USHORT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr {
    pub sa_family: ADDRESS_FAMILY,
    pub sa_data: [CHAR; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(0 as *const sockaddr)).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const sockaddr)).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
impl Clone for sockaddr {
    fn clone(&self) -> Self {
        *self
    }
}
pub type LPSOCKADDR = *mut sockaddr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SOCKET_ADDRESS {
    pub lpSockaddr: LPSOCKADDR,
    pub iSockaddrLength: INT,
}
#[test]
fn bindgen_test_layout__SOCKET_ADDRESS() {
    assert_eq!(
        ::std::mem::size_of::<_SOCKET_ADDRESS>(),
        16usize,
        concat!("Size of: ", stringify!(_SOCKET_ADDRESS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SOCKET_ADDRESS>(),
        8usize,
        concat!("Alignment of ", stringify!(_SOCKET_ADDRESS))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _SOCKET_ADDRESS)).lpSockaddr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_SOCKET_ADDRESS),
            "::",
            stringify!(lpSockaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _SOCKET_ADDRESS)).iSockaddrLength as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_SOCKET_ADDRESS),
            "::",
            stringify!(iSockaddrLength)
        )
    );
}
impl Clone for _SOCKET_ADDRESS {
    fn clone(&self) -> Self {
        *self
    }
}
pub type SOCKET_ADDRESS = _SOCKET_ADDRESS;
pub type IFTYPE = ULONG;
pub type NET_IF_COMPARTMENT_ID = UINT32;
pub type NET_IF_NETWORK_GUID = GUID;
#[repr(C)]
#[derive(Copy)]
pub union _NET_LUID_LH {
    pub Value: ULONG64,
    pub Info: _NET_LUID_LH__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _NET_LUID_LH__bindgen_ty_1 {
    pub _bitfield_1: [u32; 2usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout__NET_LUID_LH__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NET_LUID_LH__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NET_LUID_LH__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NET_LUID_LH__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NET_LUID_LH__bindgen_ty_1))
    );
}
impl Clone for _NET_LUID_LH__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl _NET_LUID_LH__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xffffff as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        let mask = 0xffffff as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn NetLuidIndex(&self) -> ULONG64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xffffff000000 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_NetLuidIndex(&mut self, val: ULONG64) {
        let mask = 0xffffff000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn IfType(&self) -> ULONG64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xffff000000000000 as u64;
        let val = (unit_field_val & mask) >> 48usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_IfType(&mut self, val: ULONG64) {
        let mask = 0xffff000000000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 48usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(Reserved: ULONG64, NetLuidIndex: ULONG64, IfType: ULONG64) -> u64 {
        (((0 | ((Reserved as u64 as u64) << 0usize) & (0xffffff as u64))
            | ((NetLuidIndex as u64 as u64) << 24usize) & (0xffffff000000 as u64))
            | ((IfType as u64 as u64) << 48usize) & (0xffff000000000000 as u64))
    }
}
#[test]
fn bindgen_test_layout__NET_LUID_LH() {
    assert_eq!(
        ::std::mem::size_of::<_NET_LUID_LH>(),
        8usize,
        concat!("Size of: ", stringify!(_NET_LUID_LH))
    );
    assert_eq!(
        ::std::mem::align_of::<_NET_LUID_LH>(),
        8usize,
        concat!("Alignment of ", stringify!(_NET_LUID_LH))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _NET_LUID_LH)).Value as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_NET_LUID_LH),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _NET_LUID_LH)).Info as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_NET_LUID_LH),
            "::",
            stringify!(Info)
        )
    );
}
impl Clone for _NET_LUID_LH {
    fn clone(&self) -> Self {
        *self
    }
}
pub type NET_LUID_LH = _NET_LUID_LH;
pub type NET_LUID = NET_LUID_LH;
pub type IF_LUID = NET_LUID;
pub type NET_IFINDEX = ULONG;
pub type IF_INDEX = NET_IFINDEX;
pub const _NET_IF_CONNECTION_TYPE_NET_IF_CONNECTION_DEDICATED: _NET_IF_CONNECTION_TYPE = 1;
pub const _NET_IF_CONNECTION_TYPE_NET_IF_CONNECTION_PASSIVE: _NET_IF_CONNECTION_TYPE = 2;
pub const _NET_IF_CONNECTION_TYPE_NET_IF_CONNECTION_DEMAND: _NET_IF_CONNECTION_TYPE = 3;
pub const _NET_IF_CONNECTION_TYPE_NET_IF_CONNECTION_MAXIMUM: _NET_IF_CONNECTION_TYPE = 4;
pub type _NET_IF_CONNECTION_TYPE = ::std::os::raw::c_int;
pub use self::_NET_IF_CONNECTION_TYPE as NET_IF_CONNECTION_TYPE;
pub const TUNNEL_TYPE_TUNNEL_TYPE_NONE: TUNNEL_TYPE = 0;
pub const TUNNEL_TYPE_TUNNEL_TYPE_OTHER: TUNNEL_TYPE = 1;
pub const TUNNEL_TYPE_TUNNEL_TYPE_DIRECT: TUNNEL_TYPE = 2;
pub const TUNNEL_TYPE_TUNNEL_TYPE_6TO4: TUNNEL_TYPE = 11;
pub const TUNNEL_TYPE_TUNNEL_TYPE_ISATAP: TUNNEL_TYPE = 13;
pub const TUNNEL_TYPE_TUNNEL_TYPE_TEREDO: TUNNEL_TYPE = 14;
pub const TUNNEL_TYPE_TUNNEL_TYPE_IPHTTPS: TUNNEL_TYPE = 15;
pub type TUNNEL_TYPE = ::std::os::raw::c_int;
pub const IF_OPER_STATUS_IfOperStatusUp: IF_OPER_STATUS = 1;
pub const IF_OPER_STATUS_IfOperStatusDown: IF_OPER_STATUS = 2;
pub const IF_OPER_STATUS_IfOperStatusTesting: IF_OPER_STATUS = 3;
pub const IF_OPER_STATUS_IfOperStatusUnknown: IF_OPER_STATUS = 4;
pub const IF_OPER_STATUS_IfOperStatusDormant: IF_OPER_STATUS = 5;
pub const IF_OPER_STATUS_IfOperStatusNotPresent: IF_OPER_STATUS = 6;
pub const IF_OPER_STATUS_IfOperStatusLowerLayerDown: IF_OPER_STATUS = 7;
pub type IF_OPER_STATUS = ::std::os::raw::c_int;
pub const NL_PREFIX_ORIGIN_IpPrefixOriginOther: NL_PREFIX_ORIGIN = 0;
pub const NL_PREFIX_ORIGIN_IpPrefixOriginManual: NL_PREFIX_ORIGIN = 1;
pub const NL_PREFIX_ORIGIN_IpPrefixOriginWellKnown: NL_PREFIX_ORIGIN = 2;
pub const NL_PREFIX_ORIGIN_IpPrefixOriginDhcp: NL_PREFIX_ORIGIN = 3;
pub const NL_PREFIX_ORIGIN_IpPrefixOriginRouterAdvertisement: NL_PREFIX_ORIGIN = 4;
pub const NL_PREFIX_ORIGIN_IpPrefixOriginUnchanged: NL_PREFIX_ORIGIN = 16;
pub type NL_PREFIX_ORIGIN = ::std::os::raw::c_int;
pub const NL_SUFFIX_ORIGIN_NlsoOther: NL_SUFFIX_ORIGIN = 0;
pub const NL_SUFFIX_ORIGIN_NlsoManual: NL_SUFFIX_ORIGIN = 1;
pub const NL_SUFFIX_ORIGIN_NlsoWellKnown: NL_SUFFIX_ORIGIN = 2;
pub const NL_SUFFIX_ORIGIN_NlsoDhcp: NL_SUFFIX_ORIGIN = 3;
pub const NL_SUFFIX_ORIGIN_NlsoLinkLayerAddress: NL_SUFFIX_ORIGIN = 4;
pub const NL_SUFFIX_ORIGIN_NlsoRandom: NL_SUFFIX_ORIGIN = 5;
pub const NL_SUFFIX_ORIGIN_IpSuffixOriginOther: NL_SUFFIX_ORIGIN = 0;
pub const NL_SUFFIX_ORIGIN_IpSuffixOriginManual: NL_SUFFIX_ORIGIN = 1;
pub const NL_SUFFIX_ORIGIN_IpSuffixOriginWellKnown: NL_SUFFIX_ORIGIN = 2;
pub const NL_SUFFIX_ORIGIN_IpSuffixOriginDhcp: NL_SUFFIX_ORIGIN = 3;
pub const NL_SUFFIX_ORIGIN_IpSuffixOriginLinkLayerAddress: NL_SUFFIX_ORIGIN = 4;
pub const NL_SUFFIX_ORIGIN_IpSuffixOriginRandom: NL_SUFFIX_ORIGIN = 5;
pub const NL_SUFFIX_ORIGIN_IpSuffixOriginUnchanged: NL_SUFFIX_ORIGIN = 16;
pub type NL_SUFFIX_ORIGIN = ::std::os::raw::c_int;
pub const NL_DAD_STATE_NldsInvalid: NL_DAD_STATE = 0;
pub const NL_DAD_STATE_NldsTentative: NL_DAD_STATE = 1;
pub const NL_DAD_STATE_NldsDuplicate: NL_DAD_STATE = 2;
pub const NL_DAD_STATE_NldsDeprecated: NL_DAD_STATE = 3;
pub const NL_DAD_STATE_NldsPreferred: NL_DAD_STATE = 4;
pub const NL_DAD_STATE_IpDadStateInvalid: NL_DAD_STATE = 0;
pub const NL_DAD_STATE_IpDadStateTentative: NL_DAD_STATE = 1;
pub const NL_DAD_STATE_IpDadStateDuplicate: NL_DAD_STATE = 2;
pub const NL_DAD_STATE_IpDadStateDeprecated: NL_DAD_STATE = 3;
pub const NL_DAD_STATE_IpDadStatePreferred: NL_DAD_STATE = 4;
pub type NL_DAD_STATE = ::std::os::raw::c_int;
pub use self::NL_DAD_STATE as IP_DAD_STATE;
pub use self::NL_PREFIX_ORIGIN as IP_PREFIX_ORIGIN;
pub use self::NL_SUFFIX_ORIGIN as IP_SUFFIX_ORIGIN;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_UNICAST_ADDRESS_LH {
    pub __bindgen_anon_1: _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1,
    pub Next: *mut _IP_ADAPTER_UNICAST_ADDRESS_LH,
    pub Address: SOCKET_ADDRESS,
    pub PrefixOrigin: IP_PREFIX_ORIGIN,
    pub SuffixOrigin: IP_SUFFIX_ORIGIN,
    pub DadState: IP_DAD_STATE,
    pub ValidLifetime: ULONG,
    pub PreferredLifetime: ULONG,
    pub LeaseLifetime: ULONG,
    pub OnLinkPrefixLength: UINT8,
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)).Length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)).Flags
                as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
impl Clone for _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1)).Alignment as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
}
impl Clone for _IP_ADAPTER_UNICAST_ADDRESS_LH__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_UNICAST_ADDRESS_LH() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_UNICAST_ADDRESS_LH>(),
        64usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_UNICAST_ADDRESS_LH>(),
        8usize,
        concat!("Alignment of ", stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).Next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).Address as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).PrefixOrigin as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(PrefixOrigin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).SuffixOrigin as *const _ as usize
        },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(SuffixOrigin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).DadState as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(DadState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).ValidLifetime as *const _ as usize
        },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(ValidLifetime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).PreferredLifetime as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(PreferredLifetime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).LeaseLifetime as *const _ as usize
        },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(LeaseLifetime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_UNICAST_ADDRESS_LH)).OnLinkPrefixLength as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_UNICAST_ADDRESS_LH),
            "::",
            stringify!(OnLinkPrefixLength)
        )
    );
}
impl Clone for _IP_ADAPTER_UNICAST_ADDRESS_LH {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PIP_ADAPTER_UNICAST_ADDRESS_LH = *mut _IP_ADAPTER_UNICAST_ADDRESS_LH;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_ANYCAST_ADDRESS_XP {
    pub __bindgen_anon_1: _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1,
    pub Next: *mut _IP_ADAPTER_ANYCAST_ADDRESS_XP,
    pub Address: SOCKET_ADDRESS,
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)).Length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)).Flags
                as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
impl Clone for _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1)).Alignment as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
}
impl Clone for _IP_ADAPTER_ANYCAST_ADDRESS_XP__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_ANYCAST_ADDRESS_XP() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_ANYCAST_ADDRESS_XP>(),
        32usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_ANYCAST_ADDRESS_XP>(),
        8usize,
        concat!("Alignment of ", stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ANYCAST_ADDRESS_XP)).Next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ANYCAST_ADDRESS_XP)).Address as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ANYCAST_ADDRESS_XP),
            "::",
            stringify!(Address)
        )
    );
}
impl Clone for _IP_ADAPTER_ANYCAST_ADDRESS_XP {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PIP_ADAPTER_ANYCAST_ADDRESS_XP = *mut _IP_ADAPTER_ANYCAST_ADDRESS_XP;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_MULTICAST_ADDRESS_XP {
    pub __bindgen_anon_1: _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1,
    pub Next: *mut _IP_ADAPTER_MULTICAST_ADDRESS_XP,
    pub Address: SOCKET_ADDRESS,
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)).Length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)).Flags
                as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
impl Clone for _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1)).Alignment as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
}
impl Clone for _IP_ADAPTER_MULTICAST_ADDRESS_XP__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_MULTICAST_ADDRESS_XP() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_MULTICAST_ADDRESS_XP>(),
        32usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_MULTICAST_ADDRESS_XP>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_MULTICAST_ADDRESS_XP)).Next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_MULTICAST_ADDRESS_XP)).Address as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_MULTICAST_ADDRESS_XP),
            "::",
            stringify!(Address)
        )
    );
}
impl Clone for _IP_ADAPTER_MULTICAST_ADDRESS_XP {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PIP_ADAPTER_MULTICAST_ADDRESS_XP = *mut _IP_ADAPTER_MULTICAST_ADDRESS_XP;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_DNS_SERVER_ADDRESS_XP {
    pub __bindgen_anon_1: _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1,
    pub Next: *mut _IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    pub Address: SOCKET_ADDRESS,
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)).Length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1)).Reserved
                as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
}
impl Clone for _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1)).Alignment as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
}
impl Clone for _IP_ADAPTER_DNS_SERVER_ADDRESS_XP__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_DNS_SERVER_ADDRESS_XP() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_DNS_SERVER_ADDRESS_XP>(),
        32usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_DNS_SERVER_ADDRESS_XP>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_DNS_SERVER_ADDRESS_XP)).Next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_DNS_SERVER_ADDRESS_XP)).Address as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_DNS_SERVER_ADDRESS_XP),
            "::",
            stringify!(Address)
        )
    );
}
impl Clone for _IP_ADAPTER_DNS_SERVER_ADDRESS_XP {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PIP_ADAPTER_DNS_SERVER_ADDRESS_XP = *mut _IP_ADAPTER_DNS_SERVER_ADDRESS_XP;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_WINS_SERVER_ADDRESS_LH {
    pub __bindgen_anon_1: _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1,
    pub Next: *mut _IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    pub Address: SOCKET_ADDRESS,
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)).Length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1))
                .Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
}
impl Clone for _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1)).Alignment as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
}
impl Clone for _IP_ADAPTER_WINS_SERVER_ADDRESS_LH__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_WINS_SERVER_ADDRESS_LH() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_WINS_SERVER_ADDRESS_LH>(),
        32usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_WINS_SERVER_ADDRESS_LH>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_WINS_SERVER_ADDRESS_LH)).Next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_WINS_SERVER_ADDRESS_LH)).Address as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_WINS_SERVER_ADDRESS_LH),
            "::",
            stringify!(Address)
        )
    );
}
impl Clone for _IP_ADAPTER_WINS_SERVER_ADDRESS_LH {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PIP_ADAPTER_WINS_SERVER_ADDRESS_LH = *mut _IP_ADAPTER_WINS_SERVER_ADDRESS_LH;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_GATEWAY_ADDRESS_LH {
    pub __bindgen_anon_1: _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1,
    pub Next: *mut _IP_ADAPTER_GATEWAY_ADDRESS_LH,
    pub Address: SOCKET_ADDRESS,
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)).Length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1)).Reserved
                as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
}
impl Clone for _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1)).Alignment as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
}
impl Clone for _IP_ADAPTER_GATEWAY_ADDRESS_LH__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_GATEWAY_ADDRESS_LH() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_GATEWAY_ADDRESS_LH>(),
        32usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_GATEWAY_ADDRESS_LH>(),
        8usize,
        concat!("Alignment of ", stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_GATEWAY_ADDRESS_LH)).Next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_GATEWAY_ADDRESS_LH)).Address as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_GATEWAY_ADDRESS_LH),
            "::",
            stringify!(Address)
        )
    );
}
impl Clone for _IP_ADAPTER_GATEWAY_ADDRESS_LH {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PIP_ADAPTER_GATEWAY_ADDRESS_LH = *mut _IP_ADAPTER_GATEWAY_ADDRESS_LH;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_PREFIX_XP {
    pub __bindgen_anon_1: _IP_ADAPTER_PREFIX_XP__bindgen_ty_1,
    pub Next: *mut _IP_ADAPTER_PREFIX_XP,
    pub Address: SOCKET_ADDRESS,
    pub PrefixLength: ULONG,
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_PREFIX_XP__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1)).Length as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1)).Flags as *const _
                as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
impl Clone for _IP_ADAPTER_PREFIX_XP__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_PREFIX_XP__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_PREFIX_XP__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_PREFIX_XP__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_PREFIX_XP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_PREFIX_XP__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_PREFIX_XP__bindgen_ty_1)).Alignment as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_PREFIX_XP__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
}
impl Clone for _IP_ADAPTER_PREFIX_XP__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_PREFIX_XP() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_PREFIX_XP>(),
        40usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_PREFIX_XP))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_PREFIX_XP>(),
        8usize,
        concat!("Alignment of ", stringify!(_IP_ADAPTER_PREFIX_XP))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_PREFIX_XP)).Next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_PREFIX_XP),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_PREFIX_XP)).Address as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_PREFIX_XP),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_PREFIX_XP)).PrefixLength as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_PREFIX_XP),
            "::",
            stringify!(PrefixLength)
        )
    );
}
impl Clone for _IP_ADAPTER_PREFIX_XP {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PIP_ADAPTER_PREFIX_XP = *mut _IP_ADAPTER_PREFIX_XP;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_DNS_SUFFIX {
    pub Next: *mut _IP_ADAPTER_DNS_SUFFIX,
    pub String: [WCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_DNS_SUFFIX() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_DNS_SUFFIX>(),
        520usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_DNS_SUFFIX))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_DNS_SUFFIX>(),
        8usize,
        concat!("Alignment of ", stringify!(_IP_ADAPTER_DNS_SUFFIX))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_DNS_SUFFIX)).Next as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_DNS_SUFFIX),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_DNS_SUFFIX)).String as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_DNS_SUFFIX),
            "::",
            stringify!(String)
        )
    );
}
impl Clone for _IP_ADAPTER_DNS_SUFFIX {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PIP_ADAPTER_DNS_SUFFIX = *mut _IP_ADAPTER_DNS_SUFFIX;
#[repr(C)]
#[derive(Copy)]
pub struct _IP_ADAPTER_ADDRESSES_LH {
    pub __bindgen_anon_1: _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1,
    pub Next: *mut _IP_ADAPTER_ADDRESSES_LH,
    pub AdapterName: PCHAR,
    pub FirstUnicastAddress: PIP_ADAPTER_UNICAST_ADDRESS_LH,
    pub FirstAnycastAddress: PIP_ADAPTER_ANYCAST_ADDRESS_XP,
    pub FirstMulticastAddress: PIP_ADAPTER_MULTICAST_ADDRESS_XP,
    pub FirstDnsServerAddress: PIP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    pub DnsSuffix: PWCHAR,
    pub Description: PWCHAR,
    pub FriendlyName: PWCHAR,
    pub PhysicalAddress: [BYTE; 8usize],
    pub PhysicalAddressLength: ULONG,
    pub __bindgen_anon_2: _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2,
    pub Mtu: ULONG,
    pub IfType: IFTYPE,
    pub OperStatus: IF_OPER_STATUS,
    pub Ipv6IfIndex: IF_INDEX,
    pub ZoneIndices: [ULONG; 16usize],
    pub FirstPrefix: PIP_ADAPTER_PREFIX_XP,
    pub TransmitLinkSpeed: ULONG64,
    pub ReceiveLinkSpeed: ULONG64,
    pub FirstWinsServerAddress: PIP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    pub FirstGatewayAddress: PIP_ADAPTER_GATEWAY_ADDRESS_LH,
    pub Ipv4Metric: ULONG,
    pub Ipv6Metric: ULONG,
    pub Luid: IF_LUID,
    pub Dhcpv4Server: SOCKET_ADDRESS,
    pub CompartmentId: NET_IF_COMPARTMENT_ID,
    pub NetworkGuid: NET_IF_NETWORK_GUID,
    pub ConnectionType: NET_IF_CONNECTION_TYPE,
    pub TunnelType: TUNNEL_TYPE,
    pub Dhcpv6Server: SOCKET_ADDRESS,
    pub Dhcpv6ClientDuid: [BYTE; 130usize],
    pub Dhcpv6ClientDuidLength: ULONG,
    pub Dhcpv6Iaid: ULONG,
    pub FirstDnsSuffix: PIP_ADAPTER_DNS_SUFFIX,
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub IfIndex: IF_INDEX,
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1)).Length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1)).IfIndex
                as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(IfIndex)
        )
    );
}
impl Clone for _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1)).Alignment as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
}
impl Clone for _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub union _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_padding_0: u16,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl Clone for _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn DdnsEnabled(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x1 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_DdnsEnabled(&mut self, val: ULONG) {
        let mask = 0x1 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn RegisterAdapterSuffix(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x2 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_RegisterAdapterSuffix(&mut self, val: ULONG) {
        let mask = 0x2 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn Dhcpv4Enabled(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x4 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_Dhcpv4Enabled(&mut self, val: ULONG) {
        let mask = 0x4 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn ReceiveOnly(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x8 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ReceiveOnly(&mut self, val: ULONG) {
        let mask = 0x8 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn NoMulticast(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x10 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_NoMulticast(&mut self, val: ULONG) {
        let mask = 0x10 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn Ipv6OtherStatefulConfig(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x20 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_Ipv6OtherStatefulConfig(&mut self, val: ULONG) {
        let mask = 0x20 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn NetbiosOverTcpipEnabled(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x40 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_NetbiosOverTcpipEnabled(&mut self, val: ULONG) {
        let mask = 0x40 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn Ipv4Enabled(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x80 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_Ipv4Enabled(&mut self, val: ULONG) {
        let mask = 0x80 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn Ipv6Enabled(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x100 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_Ipv6Enabled(&mut self, val: ULONG) {
        let mask = 0x100 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn Ipv6ManagedAddressConfigurationSupported(&self) -> ULONG {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x200 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_Ipv6ManagedAddressConfigurationSupported(&mut self, val: ULONG) {
        let mask = 0x200 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DdnsEnabled: ULONG,
        RegisterAdapterSuffix: ULONG,
        Dhcpv4Enabled: ULONG,
        ReceiveOnly: ULONG,
        NoMulticast: ULONG,
        Ipv6OtherStatefulConfig: ULONG,
        NetbiosOverTcpipEnabled: ULONG,
        Ipv4Enabled: ULONG,
        Ipv6Enabled: ULONG,
        Ipv6ManagedAddressConfigurationSupported: ULONG,
    ) -> u16 {
        ((((((((((0 | ((DdnsEnabled as u32 as u16) << 0usize) & (0x1 as u16))
            | ((RegisterAdapterSuffix as u32 as u16) << 1usize) & (0x2 as u16))
            | ((Dhcpv4Enabled as u32 as u16) << 2usize) & (0x4 as u16))
            | ((ReceiveOnly as u32 as u16) << 3usize) & (0x8 as u16))
            | ((NoMulticast as u32 as u16) << 4usize) & (0x10 as u16))
            | ((Ipv6OtherStatefulConfig as u32 as u16) << 5usize) & (0x20 as u16))
            | ((NetbiosOverTcpipEnabled as u32 as u16) << 6usize) & (0x40 as u16))
            | ((Ipv4Enabled as u32 as u16) << 7usize) & (0x80 as u16))
            | ((Ipv6Enabled as u32 as u16) << 8usize) & (0x100 as u16))
            | ((Ipv6ManagedAddressConfigurationSupported as u32 as u16) << 9usize) & (0x200 as u16))
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2)).Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2),
            "::",
            stringify!(Flags)
        )
    );
}
impl Clone for _IP_ADAPTER_ADDRESSES_LH__bindgen_ty_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout__IP_ADAPTER_ADDRESSES_LH() {
    assert_eq!(
        ::std::mem::size_of::<_IP_ADAPTER_ADDRESSES_LH>(),
        448usize,
        concat!("Size of: ", stringify!(_IP_ADAPTER_ADDRESSES_LH))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP_ADAPTER_ADDRESSES_LH>(),
        8usize,
        concat!("Alignment of ", stringify!(_IP_ADAPTER_ADDRESSES_LH))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).AdapterName as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(AdapterName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FirstUnicastAddress as *const _ as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FirstUnicastAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FirstAnycastAddress as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FirstAnycastAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FirstMulticastAddress as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FirstMulticastAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FirstDnsServerAddress as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FirstDnsServerAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).DnsSuffix as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(DnsSuffix)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Description as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Description)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FriendlyName as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FriendlyName)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).PhysicalAddress as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(PhysicalAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).PhysicalAddressLength as *const _ as usize
        },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(PhysicalAddressLength)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Mtu as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).IfType as *const _ as usize },
        100usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(IfType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).OperStatus as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(OperStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Ipv6IfIndex as *const _ as usize },
        108usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Ipv6IfIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).ZoneIndices as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(ZoneIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FirstPrefix as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FirstPrefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).TransmitLinkSpeed as *const _ as usize
        },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(TransmitLinkSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).ReceiveLinkSpeed as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(ReceiveLinkSpeed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FirstWinsServerAddress as *const _ as usize
        },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FirstWinsServerAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FirstGatewayAddress as *const _ as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FirstGatewayAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Ipv4Metric as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Ipv4Metric)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Ipv6Metric as *const _ as usize },
        220usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Ipv6Metric)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Luid as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Luid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Dhcpv4Server as *const _ as usize },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Dhcpv4Server)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).CompartmentId as *const _ as usize },
        248usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(CompartmentId)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).NetworkGuid as *const _ as usize },
        252usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(NetworkGuid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).ConnectionType as *const _ as usize },
        268usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(ConnectionType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).TunnelType as *const _ as usize },
        272usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(TunnelType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Dhcpv6Server as *const _ as usize },
        280usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Dhcpv6Server)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Dhcpv6ClientDuid as *const _ as usize },
        296usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Dhcpv6ClientDuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Dhcpv6ClientDuidLength as *const _ as usize
        },
        428usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Dhcpv6ClientDuidLength)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).Dhcpv6Iaid as *const _ as usize },
        432usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(Dhcpv6Iaid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IP_ADAPTER_ADDRESSES_LH)).FirstDnsSuffix as *const _ as usize },
        440usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IP_ADAPTER_ADDRESSES_LH),
            "::",
            stringify!(FirstDnsSuffix)
        )
    );
}
impl Clone for _IP_ADAPTER_ADDRESSES_LH {
    fn clone(&self) -> Self {
        *self
    }
}
pub type IP_ADAPTER_ADDRESSES_LH = _IP_ADAPTER_ADDRESSES_LH;
pub type PIP_ADAPTER_ADDRESSES = *mut IP_ADAPTER_ADDRESSES_LH;
extern "C" {
    pub fn GetAdaptersAddresses(
        Family: ULONG,
        Flags: ULONG,
        Reserved: PVOID,
        AdapterAddresses: PIP_ADAPTER_ADDRESSES,
        SizePointer: PULONG,
    ) -> ULONG;
}
